<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>1984 Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1c1c1c;
            color: #e0e0e0;
            font-family: monospace;
        }
        .game-screen {
            background-color: #2c2c2c;
            border: 2px solid #4a4a4a;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        .telescreen-effect {
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.1) 0px,
                rgba(0,0,0,0.2) 2px,
                transparent 2px,
                transparent 4px
            );
        }
        .dialog-box {
            background-color: rgba(20,20,20,0.9);
            border: 1px solid #3a3a3a;
        }
        .map-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }
        .map-tile {
            background-color: #3c3c3c;
            border: 1px solid #4a4a4a;
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .player-tile {
            background-color: #5a5a5a;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex items-center justify-center">
    <div class="game-screen w-4/5 h-[700px] p-4 rounded-lg telescreen-effect flex flex-col">
        <div class="game-header text-center mb-4">
            <h1 class="text-2xl font-bold uppercase tracking-widest">Ministry of Truth Simulator</h1>
            <div id="role-display" class="text-sm text-gray-500">Role: Loading...</div>
        </div>
        
        <div class="game-content flex flex-grow">
            <div class="map-container w-2/3 p-2">
                <div id="game-map" class="map-grid h-full">
                    <!-- Map tiles will be generated here -->
                </div>
            </div>
            
            <div class="dialog-container w-1/3 p-2">
                <div id="dialog-box" class="dialog-box h-full p-4 rounded">
                    <div id="dialog-text" class="mb-4">Welcome to the Ministry. Await further instructions.</div>
                    <div id="dialog-options" class="space-y-2">
                        <!-- Dialog options will be dynamically inserted -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar flex justify-between text-xs text-gray-500 mt-2">
            <div id="meters">
                Loyalty: <span id="loyalty-meter">50</span> | 
                Rebellion: <span id="rebellion-meter">0</span> | 
                Survival: <span id="survival-meter">100</span>
            </div>
            <div>Big Brother is Watching</div>
        </div>
    </div>

    <script>
    class GameManager {
        constructor() {
            this.playerRole = null;
            this.gameState = 'inactive';
            this.suspicionLevel = 0;
            this.meterValues = {
                loyalty: 50,
                rebellion: 0,
                survival: 100
            };
        }

        initializeGame() {
            this.assignRole();
            this.gameState = 'active';
            console.log(`Game started. Role: ${this.playerRole}`);
        }

        assignRole() {
            const roles = ['Editor', 'Surveillance Officer', 'Propaganda Developer'];
            this.playerRole = roles[Math.floor(Math.random() * roles.length)];
        }

        updateGameState() {
            // Check game progression conditions
            if (this.suspicionLevel > 75) {
                this.endGame('captured');
            }
        }

        applyConsequences(action) {
            // Modify meters based on player actions
            switch(action) {
                case 'loyal_action':
                    this.meterValues.loyalty = Math.min(100, this.meterValues.loyalty + 10);
                    this.suspicionLevel = Math.max(0, this.suspicionLevel - 5);
                    break;
                case 'rebellious_action':
                    this.meterValues.rebellion = Math.min(100, this.meterValues.rebellion + 10);
                    this.suspicionLevel = Math.min(100, this.suspicionLevel + 10);
                    break;
            }
            this.updateGameState();
        }

        endGame(type) {
            this.gameState = 'ended';
            console.log(`Game ended: ${type}`);
            // Trigger appropriate ending scene
            alert(`Game Over: ${type}`);
        }
    }

    class Player {
        constructor(gameManager) {
            this.gameManager = gameManager;
            this.collectedDocuments = [];
        }

        performAction(actionType) {
            // Interact with game systems based on action
            this.gameManager.applyConsequences(actionType);
        }

        collectFragment(fragment) {
            this.collectedDocuments.push(fragment);
            this.gameManager.applyConsequences('rebellious_action');
        }
    }

    class DialogSystem {
        constructor(gameManager) {
            this.gameManager = gameManager;
            this.dialogBox = document.getElementById('dialog-text');
            this.optionsBox = document.getElementById('dialog-options');
        }

        displayDialog(text, options = []) {
            this.dialogBox.textContent = text;
            this.optionsBox.innerHTML = '';
            
            // Show the dialog box
            this.dialogBox.style.display = 'block';
            this.optionsBox.style.display = 'block';
            
            options.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option.text;
                button.className = 'w-full p-2 bg-gray-700 hover:bg-gray-600 rounded';
                button.onclick = () => {
                    // Handle the option
                    this.handleOption(option);
                    
                    // Hide the dialog box
                    this.dialogBox.style.display = 'none';
                    this.optionsBox.style.display = 'none';
                };
                this.optionsBox.appendChild(button);
            });
        }
        
        handleOption(option) {
            // Process dialog option and its consequences
            this.gameManager.applyConsequences(option.action);
            
            // Update UI
            this.updateMeters();
            
            // Potentially trigger next dialog or event
            if (option.nextDialog) {
                this.displayDialog(option.nextDialog.text, option.nextDialog.options);
            }
        }

        updateMeters() {
            const meters = this.gameManager.meterValues;
            document.getElementById('loyalty-meter').textContent = meters.loyalty;
            document.getElementById('rebellion-meter').textContent = meters.rebellion;
            document.getElementById('survival-meter').textContent = meters.survival;
        }
    }

    class MapSystem {
        constructor(gameManager) {
            this.gameManager = gameManager;
            this.mapElement = document.getElementById('game-map');
            this.playerPosition = { x: 2, y: 2 };
            this.initializeMap();
            this.setupKeyboardControls();
        }

        initializeMap() {
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    const tile = document.createElement('div');
                    tile.classList.add('map-tile');
                    tile.dataset.x = x;
                    tile.dataset.y = y;
                    
                    if (x === this.playerPosition.x && y === this.playerPosition.y) {
                        tile.classList.add('player-tile');
                        tile.textContent = 'ðŸ•´ï¸';
                    }
                    
                    this.mapElement.appendChild(tile);
                }
            }
        }

        setupKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                const moves = {
                    'ArrowUp': { x: 0, y: -1 },
                    'ArrowDown': { x: 0, y: 1 },
                    'ArrowLeft': { x: -1, y: 0 },
                    'ArrowRight': { x: 1, y: 0 }
                };

                const move = moves[event.key];
                if (move) {
                    this.movePlayer(move.x, move.y);
                }
            });
        }

        movePlayer(dx, dy) {
            const newX = this.playerPosition.x + dx;
            const newY = this.playerPosition.y + dy;

            // Boundary check
            if (newX >= 0 && newX < 5 && newY >= 0 && newY < 5) {
                // Remove old player tile
                const oldTile = this.mapElement.querySelector('.player-tile');
                oldTile.classList.remove('player-tile');
                oldTile.textContent = '';

                // Set new player position
                this.playerPosition = { x: newX, y: newY };

                // Mark new tile
                const newTile = this.mapElement.querySelector(`[data-x="${newX}"][data-y="${newY}"]`);
                newTile.classList.add('player-tile');
                newTile.textContent = 'ðŸ•´ï¸';

                // Potentially trigger an event based on new location
                this.checkLocationEvent();
            }
        }

        checkLocationEvent() {
            // Placeholder for location-based events
            const eventProbability = Math.random();
            if (eventProbability < 0.2) {  // 20% chance of an event
                this.triggerRandomEvent();
            }
        }

        triggerRandomEvent() {
            const events = [
                {
                    text: "You notice a suspicious document on a nearby desk. Do you investigate?",
                    options: [
                        { 
                            text: "Investigate the document", 
                            action: 'rebellious_action',
                            nextDialog: {
                                text: "You find a fragment revealing the Party's manipulation.",
                                options: [
                                    { text: "Keep the fragment", action: 'rebellious_action' },
                                    { text: "Report it", action: 'loyal_action' }
                                ]
                            }
                        },
                        { 
                            text: "Ignore it", 
                            action: 'loyal_action' 
                        }
                    ]
                }
            ];

            const selectedEvent = events[0];
            dialogSystem.displayDialog(selectedEvent.text, selectedEvent.options);
        }
    }

    // Global variables to allow interaction in console
    let gameManager, dialogSystem, mapSystem, player;

    // Initialization
    document.addEventListener('DOMContentLoaded', () => {
        gameManager = new GameManager();
        gameManager.initializeGame();

        // Update role display
        document.getElementById('role-display').textContent = `Role: ${gameManager.playerRole}`;

        player = new Player(gameManager);
        dialogSystem = new DialogSystem(gameManager);
        mapSystem = new MapSystem(gameManager);

        // Initial welcome dialog
        dialogSystem.displayDialog(
            `Welcome to the Ministry of Truth. You have been assigned the role of ${gameManager.playerRole}. Remain vigilant.`,
            [
                { 
                    text: "Understand", 
                    action: 'loyal_action' 
                }
            ]
        );
    });
    </script>
</body>
</html>